#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <pthread.h>

#define LOWER_LIMIT       0
#define UPPER_LIMIT     100
#define MAX              50

typedef struct {
    int* v;
    int size;
    int index;
    int min;
    int max;
    int* res;
    int* res_idx;
} thread_args;

/**
 * Generates a random number between min and max.
 * The number sequence generated by the fuction rand is always the 
 * same because it uses the defaulta seed 0.
 */
int get_random (int min, int max) {
    return rand() % (max - min + 1) + min;
}

/**
 * Starts the vector with random values belonging to the interval [min..max]
 */
void vector_init_rand (int v[], long dim, int min, int max) {
    for (long i = 0; i < dim; i++)
        v[i] = get_random(min, max);
}

/**
 * Gets the subvector of values in the range [min..max]
*/
void range_child(thread_args* args) {
    for (int j = args->index * args->size; j < (args->index + 1) * args->size; j++) {
        if (args->v[j] >= args->min && args->v[j] <= args->max)
            args->res[*args->res_idx++] = args->v[j];
    }

    pthread_exit(NULL);
}

/**
 * Gets the subvector of values in the range [min..max]
 * 
 * returns the number of values store in subvector sv 
 */
int vector_get_in_range(int v[], int v_sz, int sv[], int min, int max, int n_threads) {
    pthread_t th[MAX];
    int res_idx = 0;
    int subarray_size = v_sz / n_threads;

    for (int i = 0; i < n_threads; i++) {
        thread_args targs;
        targs.v = v;
        targs.size = subarray_size;
        targs.min = min;
        targs.max = max;
        targs.res = sv;
        targs.res_idx = &res_idx;
        targs.index = i;

        pthread_create(&th[i], NULL, (void *(*)(void *))range_child, (void *)&targs);
    }

    for (int i = 0; i < n_threads; i++)
        pthread_join(th[i], NULL);

    return res_idx;
}

int main(int argc, char *argv[]){
    if (argc < 3) {
        printf("Usage: %s <vector dimension> <number threads>\n", argv[0]);
        exit(1);
    }

    long values_sz = atol(argv[1]);
    int n_threads = atoi(argv[2]);

    printf("Initializing a vector of %ld bytes\n", values_sz);

    // allocate a vector of initial values
    int *values = malloc(sizeof(int) * values_sz);
    if (values == NULL) {
        fprintf(stderr, "Erro malloc\n");
        return -1;
    }

    // allocate a subvector where will be store values in a interval of values
    int *subvalues = malloc(sizeof(int) * values_sz);
    if (subvalues == NULL) {
        fprintf(stderr, "Erro malloc\n");
        return -1;
    }

    // initiate initial array of values 
    vector_init_rand(values, values_sz, LOWER_LIMIT, UPPER_LIMIT);

    struct timeval t1,t2;
    gettimeofday(&t1, NULL);

    // start of code to evaluate

    long count     = 0;
    int values_min = 50;
    int values_max = 100;

    count = vector_get_in_range(values, values_sz, subvalues, values_min, values_max, n_threads);

    // end of code to evaluate

    gettimeofday(&t2, NULL);
    long elapsed = ((long)t2.tv_sec - t1.tv_sec) * 1000000L + (t2.tv_usec - t1.tv_usec);
    long sec = elapsed / (long)1e6;
    long aux = elapsed % (long)1e6;
    long mil = aux / (long)1e3;
    long mic = aux % (long)1e3;

    free(values);
    free(subvalues);

    printf("Elapsed time = %lds%ld,%ldms\n", sec, mil, mic);
    printf("Values between [%d..%d]: %ld\n", values_min, values_max, count);

    return 0;
}